<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kai.Yang&#39; Blog</title>
  <subtitle>生命不止、奋斗不息</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yangkai0725.com/"/>
  <updated>2016-08-23T11:49:03.676Z</updated>
  <id>http://www.yangkai0725.com/</id>
  
  <author>
    <name>kaiyang</name>
    <email>fox520527088@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux之less命令</title>
    <link href="http://www.yangkai0725.com/20160822/20160822linux-less-command.html"/>
    <id>http://www.yangkai0725.com/20160822/20160822linux-less-command.html</id>
    <published>2016-08-22T15:16:03.000Z</published>
    <updated>2016-08-23T11:49:03.676Z</updated>
    
    <content type="html"><![CDATA[<p>Linux中的less命令主要用来浏览文件内容，与more命令的用法相似，不同于more命令的是，less命令可往回卷动浏览以看过的部分。</p>
<a id="more"></a>
<p>参考：<a href="http://www.xitongzhijia.net/xtjc/20141209/32242.html" target="_blank" rel="external">http://www.xitongzhijia.net/xtjc/20141209/32242.html</a><br>less 的用法比起 more 更加的有弹性。在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 ［pageup］ ［pagedown］ 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。</p>
<h1 id="1．命令格式"><a href="#1．命令格式" class="headerlink" title="1．命令格式"></a>1．命令格式</h1><p>　　less［参数］ 文件</p>
<h1 id="2．命令功能"><a href="#2．命令功能" class="headerlink" title="2．命令功能"></a>2．命令功能</h1><p>less与more类似,但使用less可以随意浏览文件，而more仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</p>
<h1 id="3．命令参数"><a href="#3．命令参数" class="headerlink" title="3．命令参数"></a>3．命令参数</h1><pre><code>-b 《缓冲区大小》 设置缓冲区的大小
-e 当文件显示结束后，自动离开
-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件
-g 只标志最后搜索的关键词
-i 忽略搜索时的大小写
-m 显示类似more命令的百分比
-N 显示每行的行号
-o 《文件名》 将less 输出的内容在指定文件中保存起来
-Q 不使用警告音
-s 显示连续空行为一行
-S 行过长时间将超出部分舍弃
-x 《数字》 将“tab”键显示为规定的数字空格
/字符串：向下搜索“字符串”的功能
？字符串：向上搜索“字符串”的功能
n：重复前一个搜索（与 / 或 ？ 有关）
N：反向重复前一个搜索（与 / 或 ？ 有关）
b 向后翻一页
d 向后翻半页
h 显示帮助界面
Q 退出less 命令
u 向前滚动半页
y 向前滚动一行
空格键 滚动一行
回车键 滚动一页
[pagedown］： 向下翻动一页
［pageup］： 向上翻动一页
</code></pre><h1 id="4．使用实例"><a href="#4．使用实例" class="headerlink" title="4．使用实例"></a>4．使用实例</h1><blockquote>
<p> 实例1：查看文件</p>
</blockquote>
<pre><code>[yxgly@ZC_VM_10_100_138_183 ~]$ less 2016.log 
a2016


b2015


c3333333333333
2016.log (END) 
</code></pre><p>　　</p>
<blockquote>
<p> 实例2：ps查看进程信息并通过less分页显示</p>
</blockquote>
<pre><code>[yxgly@ZC_VM_10_100_138_183 ~]$ ps -ef |less
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 Jul30 ?        00:00:00 /sbin/init
root         2     0  0 Jul30 ?        00:00:00 [kthreadd]
root         3     2  0 Jul30 ?        00:00:00 [migration/0]
root         4     2  0 Jul30 ?        00:00:03 [ksoftirqd/0]
root         5     2  0 Jul30 ?        00:00:00 [migration/0]
root         6     2  0 Jul30 ?        00:00:03 [watchdog/0]
root         7     2  0 Jul30 ?        00:38:46 [events/0]
root         8     2  0 Jul30 ?        00:00:00 [cgroup]
root         9     2  0 Jul30 ?        00:00:00 [khelper]
root        10     2  0 Jul30 ?        00:00:00 [netns]
root        11     2  0 Jul30 ?        00:00:00 [async/mgr]
root        12     2  0 Jul30 ?        00:00:00 [pm]
root        13     2  0 Jul30 ?        00:00:08 [sync_supers]
root        14     2  0 Jul30 ?        00:00:08 [bdi-default]
root        15     2  0 Jul30 ?        00:00:00 [kintegrityd/0]
root        16     2  0 Jul30 ?        00:00:16 [kblockd/0]
root        17     2  0 Jul30 ?        00:00:00 [kacpid]
root        18     2  0 Jul30 ?        00:00:00 [kacpi_notify]
root        19     2  0 Jul30 ?        00:00:00 [kacpi_hotplug]
root        20     2  0 Jul30 ?        00:00:00 [ata_aux]
root        21     2  0 Jul30 ?        00:00:00 [ata_sff/0]
root        22     2  0 Jul30 ?        00:00:00 [ksuspend_usbd]
root        23     2  0 Jul30 ?        00:00:00 [khubd]
root        24     2  0 Jul30 ?        00:00:00 [kseriod]
root        25     2  0 Jul30 ?        00:00:00 [md/0]
</code></pre><blockquote>
<p>  实例3：查看命令历史使用记录并通过less分页显示</p>
</blockquote>
<pre><code>[yxgly@ZC_VM_10_100_138_183 ~]$ history | less
54  cd logs/
55  ll
56  rm catalina.out 
57  ll
58  cd ..
59  ll
60  cd work/Catalina/localhost/
61  ll
62  rm -rf *
63  cd ..
64  ll
65  cd bin/
66  ll
67  vi startup.sh 
68  ll
69  cd ..
70  cd conf/
71  ll
72  vi server.xml 
73  cd ..
74  cd yangkai/
</code></pre><blockquote>
<p>  实例4：浏览多个文件</p>
</blockquote>
<pre><code>[yxgly@ZC_VM_10_100_138_183 ~]$ less 2016.log 2015.log 
a2016


b2015


c3333333333333
</code></pre><p>2016.log (file 1 of 2) (END) - Next: 2015.log</p>
<p>:n</p>
<pre><code>2015
2015
~
~
~
~
~
2015.log (file 2 of 2) (END) 
</code></pre><blockquote>
<p>　　<em>说明：<br>　　输入 ：n后，切换到 log2014.log<br>　　输入 ：p 后，切换到log2013.log</em></p>
</blockquote>
<h1 id="5．附加备注"><a href="#5．附加备注" class="headerlink" title="5．附加备注"></a>5．附加备注</h1><blockquote>
<p>  全屏导航</p>
</blockquote>
<pre><code>ctrl + F - 向前移动一屏
ctrl + B - 向后移动一屏
ctrl + D - 向前移动半屏
ctrl + U - 向后移动半屏
</code></pre><blockquote>
<p>　单行导航</p>
</blockquote>
<pre><code>j - 向前移动一行
k - 向后移动一行
3.其它导航
G - 移动到最后一行
g - 移动到第一行
q / ZZ - 退出 less 命令
</code></pre><blockquote>
<p>  其它有用的命令</p>
</blockquote>
<pre><code>v - 使用配置的编辑器编辑当前文件
h - 显示 less 的帮助文档
&amp;pattern - 仅显示匹配模式的行，而不是整个文件
</code></pre><blockquote>
<p>  标记导航</p>
</blockquote>
<pre><code>当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置：
ma - 使用 a 标记文本的当前位置
‘a - 导航到标记 a 处
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux中的less命令主要用来浏览文件内容，与more命令的用法相似，不同于more命令的是，less命令可往回卷动浏览以看过的部分。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.yangkai0725.com/categories/linux/"/>
    
    
      <category term="java" scheme="http://www.yangkai0725.com/tags/java/"/>
    
      <category term="linux" scheme="http://www.yangkai0725.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>数据库面试常问的一些基本概念</title>
    <link href="http://www.yangkai0725.com/20160822/20160822%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html"/>
    <id>http://www.yangkai0725.com/20160822/20160822数据库面试常问的一些基本概念.html</id>
    <published>2016-08-22T04:29:12.000Z</published>
    <updated>2016-08-23T01:29:15.733Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>超键、候选键、主键、外键</li>
<li>什么是事务？什么是锁？</li>
<li>数据库事务的四个特性及含义</li>
<li>什么是视图？</li>
<li>触发器的作用？</li>
<li>维护数据库的完整性和一致性，你喜欢用触发器还是自写业务逻辑？为什么？</li>
<li>索引的作用？和它的优点缺点是什么？</li>
<li>drop,delete与truncate的区别</li>
</ul>
<a id="more"></a>
<h1 id="1-超键、候选键、主键、外键"><a href="#1-超键、候选键、主键、外键" class="headerlink" title="1. 超键、候选键、主键、外键"></a>1. 超键、候选键、主键、外键</h1><p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p>
<p>候选键：是最小超键，即没有冗余元素的超键。</p>
<p>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</p>
<p>外键：在一个表中存在的另一个表的主键称此表的外键。</p>
<h1 id="2-什么是事务？什么是锁？"><a href="#2-什么是事务？什么是锁？" class="headerlink" title="2.  什么是事务？什么是锁？"></a>2.  什么是事务？什么是锁？</h1><p>事务：就是被绑定在一起作为一个逻辑工作单元的 SQL 语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过 ACID 测试，即原子性，一致性，隔离性和持久性。</p>
<p>锁：在所以的 DBMS 中，锁是实现事务的关键，锁可以保证事务的完整性和并发性。与现实生活中锁一样，它可以使某些数据的拥有者，在某段时间内不能使用某些数据或数据结构。当然锁还分级别的。</p>
<h1 id="3-数据库事务的四个特性及含义"><a href="#3-数据库事务的四个特性及含义" class="headerlink" title="3. 数据库事务的四个特性及含义"></a>3. 数据库事务的四个特性及含义</h1><p>原子性：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
<p>一致性：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。<br>隔离性：隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。</p>
<p>持久性：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p>
<h1 id="4-什么是视图？"><a href="#4-什么是视图？" class="headerlink" title="4. 什么是视图？"></a>4. 什么是视图？</h1><p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</p>
<p>如下两种场景一般会使用到视图：</p>
<p>（1）不希望访问者获取整个表的信息，只暴露部分字段给访问者，所以就建一个虚表，就是视图。<br>（2）查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异。</p>
<p>注：这个视图是在数据库中创建的 而不是用代码创建的。</p>
<h1 id="5-触发器的作用？"><a href="#5-触发器的作用？" class="headerlink" title="5. 触发器的作用？"></a>5. 触发器的作用？</h1><p>触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p>
<h1 id="6-维护数据库的完整性和一致性，你喜欢用触发器还是自写业务逻辑？为什么？"><a href="#6-维护数据库的完整性和一致性，你喜欢用触发器还是自写业务逻辑？为什么？" class="headerlink" title="6. 维护数据库的完整性和一致性，你喜欢用触发器还是自写业务逻辑？为什么？"></a>6. 维护数据库的完整性和一致性，你喜欢用触发器还是自写业务逻辑？为什么？</h1><p>尽可能使用约束，如 check, 主键，外键，非空字段等来约束，这样做效率最高，也最方便。其次是使用触发器，这种方法可以保证，无论什么业务系统访问数据库都可以保证数据的完整新和一致性。最后考虑的是自写业务逻辑，但这样做麻烦，编程复杂，效率低下。</p>
<h1 id="7-索引的作用？和它的优点缺点是什么？"><a href="#7-索引的作用？和它的优点缺点是什么？" class="headerlink" title="7. 索引的作用？和它的优点缺点是什么？"></a>7. 索引的作用？和它的优点缺点是什么？</h1><p>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p>
<p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<p>为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</p>
<p>创建索引可以大大提高系统的性能（优点）：</p>
<p>第一、通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。<br>第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。<br>第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。<br>第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。<br>第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p>
<p>也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面：</p>
<p>第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。<br>第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p>
<p>第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p>
<p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。</p>
<p>一般来说，应该在这些列上创建索引：</p>
<p>（1）在经常需要搜索的列上，可以加快搜索的速度；<br>（2）在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；<br>（3）在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；<br>（4）在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；<br>（5）在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；<br>（6）在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。<br>同样，对于有些列不应该创建索引：</p>
<p>第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p>
<p>第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p>
<p>第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</p>
<p>第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p>
<h1 id="8-drop-delete与truncate的区别"><a href="#8-drop-delete与truncate的区别" class="headerlink" title="8. drop,delete与truncate的区别"></a>8. drop,delete与truncate的区别</h1><p>drop直接删掉表 。 </p>
<p>truncate删除表中数据，再插入时自增长id又从1开始 。 </p>
<p>delete删除表中数据，可以加where字句。</p>
<p>（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p>
<p>（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。</p>
<p>（3） 一般而言，drop &gt; truncate &gt; delete</p>
<p>（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view</p>
<p>（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。</p>
<p>（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。</p>
<p>（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。</p>
<p>（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚。</p>
<p>（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。</p>
<p>（10） Truncate table 表名 速度快,而且效率高,因为: </p>
<p>truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</p>
<p>（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。</p>
<p>（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;超键、候选键、主键、外键&lt;/li&gt;
&lt;li&gt;什么是事务？什么是锁？&lt;/li&gt;
&lt;li&gt;数据库事务的四个特性及含义&lt;/li&gt;
&lt;li&gt;什么是视图？&lt;/li&gt;
&lt;li&gt;触发器的作用？&lt;/li&gt;
&lt;li&gt;维护数据库的完整性和一致性，你喜欢用触发器还是自写业务逻辑？为什么？&lt;/li&gt;
&lt;li&gt;索引的作用？和它的优点缺点是什么？&lt;/li&gt;
&lt;li&gt;drop,delete与truncate的区别&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.yangkai0725.com/categories/interview/"/>
    
    
      <category term="database" scheme="http://www.yangkai0725.com/tags/database/"/>
    
      <category term="interview" scheme="http://www.yangkai0725.com/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>创建svn服务及svn提交忽略</title>
    <link href="http://www.yangkai0725.com/20160821/20160821%E5%88%9B%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1.html"/>
    <id>http://www.yangkai0725.com/20160821/20160821创建svn服务.html</id>
    <published>2016-08-21T08:16:01.000Z</published>
    <updated>2016-08-22T01:35:38.567Z</updated>
    
    <content type="html"><![CDATA[<p>Windows平台上创建SVN服务，方便启动和关闭。<br><a id="more"></a></p>
<h1 id="创建svn服务"><a href="#创建svn服务" class="headerlink" title="创建svn服务"></a>创建svn服务</h1><pre><code>sc create svn binpath= &quot;D:\Program Files (x86)\Subversion\bin\svnserve.exe --service -r E:\joiest\svnRepo&quot; displayname= &quot;Subversion Server&quot; depend= tcpip start= auto
</code></pre><blockquote>
<p>  开启：net start svn<br>  关闭：net stop svn</p>
</blockquote>
<h1 id="Eclipse中svn提交时忽略文件"><a href="#Eclipse中svn提交时忽略文件" class="headerlink" title="Eclipse中svn提交时忽略文件"></a>Eclipse中svn提交时忽略文件</h1><p>Windows –&gt; preferences –&gt; Team –&gt; Ignore Resources –&gt; Add Pattern<br>之后分别添加下面四项，并点击OK</p>
<pre><code>.classpath
.project
target
.settings
.externalToolBuilders
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Windows平台上创建SVN服务，方便启动和关闭。&lt;br&gt;
    
    </summary>
    
      <category term="svn" scheme="http://www.yangkai0725.com/categories/svn/"/>
    
    
      <category term="svn" scheme="http://www.yangkai0725.com/tags/svn/"/>
    
      <category term="eclipse" scheme="http://www.yangkai0725.com/tags/eclipse/"/>
    
  </entry>
  
  <entry>
    <title>数据库日期字符串数字转换</title>
    <link href="http://www.yangkai0725.com/20160821/20160821%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2.html"/>
    <id>http://www.yangkai0725.com/20160821/20160821数据库日期转换.html</id>
    <published>2016-08-21T07:20:24.000Z</published>
    <updated>2016-08-22T01:35:38.568Z</updated>
    
    <content type="html"><![CDATA[<p>日期字符串相互转换。</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th>类别</th>
<th style="text-align:center">格式</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">期望值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Year</td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td></td>
<td style="text-align:center">yy</td>
<td style="text-align:left">two digits 两位年</td>
<td style="text-align:left">显示值:07</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">yyy</td>
<td style="text-align:left">three digits 三位年</td>
<td style="text-align:left">显示值:007</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">yyyy</td>
<td style="text-align:left">four digits 四位年</td>
<td style="text-align:left">显示值:2007</td>
</tr>
<tr>
<td>Month</td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td></td>
<td style="text-align:center">mm</td>
<td style="text-align:left">number     两位月</td>
<td style="text-align:left">显示值:11</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">mon</td>
<td style="text-align:left">abbreviated 字符集表示</td>
<td style="text-align:left">显示值:11月,若是英文版,显示nov</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">month</td>
<td style="text-align:left">spelled out 字符集表示</td>
<td style="text-align:left">显示值:11月,若是英文版,显示november</td>
</tr>
<tr>
<td>Day</td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td></td>
<td style="text-align:center">dd</td>
<td style="text-align:left">number 当月第几天</td>
<td style="text-align:left">显示值:02</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">ddd</td>
<td style="text-align:left">number 当年第几天</td>
<td style="text-align:left">显示值:02</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">dy</td>
<td style="text-align:left">abbreviated 当周第几天简写</td>
<td style="text-align:left">显示值:星期五,若是英文版,显示fri</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">day</td>
<td style="text-align:left">spelled out 当周第几天全写</td>
<td style="text-align:left">显示值:星期五,若是英文版,显示friday</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">ddspth</td>
<td style="text-align:left">spelled out, ordinal twelfth</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>Hour</td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td></td>
<td style="text-align:center">hh</td>
<td style="text-align:left">two digits 12小时进制</td>
<td style="text-align:left">显示值:01</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">hh24</td>
<td style="text-align:left">two digits 24小时进制</td>
<td style="text-align:left">显示值:13</td>
</tr>
<tr>
<td>Minute</td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td></td>
<td style="text-align:center">mi</td>
<td style="text-align:left">two digits 60进制</td>
<td style="text-align:left">显示值:45</td>
</tr>
<tr>
<td>Second</td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td></td>
<td style="text-align:center">ss</td>
<td style="text-align:left">two digits 60进制</td>
<td style="text-align:left">显示值:25</td>
</tr>
</tbody>
</table>
<h1 id="时间转化为字符串"><a href="#时间转化为字符串" class="headerlink" title="时间转化为字符串"></a>时间转化为字符串</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> to_char(<span class="keyword">sysdate</span>,<span class="string">'yyyy-mm-dd hh24:mi:ss'</span>) <span class="keyword">as</span> nowTime <span class="keyword">from</span> dual;</div></pre></td></tr></table></figure>
<h1 id="字符串转化为时间"><a href="#字符串转化为时间" class="headerlink" title="字符串转化为时间"></a>字符串转化为时间</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">to_date</span>(<span class="string">'2004-05-07 13:23:44'</span>,<span class="string">'yyyy-mm-dd hh24:mi:ss'</span>) <span class="keyword">from</span> dual;</div></pre></td></tr></table></figure>
<h1 id="数字转化为英文"><a href="#数字转化为英文" class="headerlink" title="数字转化为英文"></a>数字转化为英文</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> to_char( <span class="keyword">to_date</span>(<span class="number">456</span>,<span class="string">'J'</span>),<span class="string">'Jsp'</span>) <span class="keyword">from</span> dual;</div></pre></td></tr></table></figure>
<h1 id="当前时间为周几"><a href="#当前时间为周几" class="headerlink" title="当前时间为周几"></a>当前时间为周几</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> to_char(<span class="keyword">sysdate</span>,<span class="string">'day'</span>) <span class="keyword">from</span> dual;</div></pre></td></tr></table></figure>
<h1 id="两日期之间的天数"><a href="#两日期之间的天数" class="headerlink" title="两日期之间的天数"></a>两日期之间的天数</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">floor</span>(<span class="keyword">sysdate</span> - <span class="keyword">to_date</span>(<span class="string">'20020405'</span>,<span class="string">'yyyymmdd'</span>)) <span class="keyword">from</span> dual;</div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> to_char(<span class="keyword">sysdate</span>,<span class="string">'hh:mi:ss'</span>) <span class="keyword">TIME</span> <span class="keyword">from</span> all_objects <span class="keyword">where</span> <span class="keyword">rownum</span> &lt; <span class="number">2001</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日期字符串相互转换。&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="http://www.yangkai0725.com/categories/database/"/>
    
    
      <category term="java" scheme="http://www.yangkai0725.com/tags/java/"/>
    
      <category term="database" scheme="http://www.yangkai0725.com/tags/database/"/>
    
      <category term="date" scheme="http://www.yangkai0725.com/tags/date/"/>
    
  </entry>
  
  <entry>
    <title>redis常用命令大全</title>
    <link href="http://www.yangkai0725.com/20160820/20160820redisOftenUseCommand.html"/>
    <id>http://www.yangkai0725.com/20160820/20160820redisOftenUseCommand.html</id>
    <published>2016-08-20T14:30:10.000Z</published>
    <updated>2016-08-22T01:35:38.566Z</updated>
    
    <content type="html"><![CDATA[<p>Key、服务器相关的一些常用redis命令。<br>速查：<a href="http://www.cnblogs.com/kissdodog/p/3599047.html" target="_blank" rel="external">http://www.cnblogs.com/kissdodog/p/3599047.html</a></p>
<a id="more"></a>
<h1 id="Key相关命令"><a href="#Key相关命令" class="headerlink" title="Key相关命令"></a>Key相关命令</h1><p>keys * 取出当前所有的key</p>
<p>exists name 查看n是否有name这个key</p>
<p>del name 删除key name</p>
<p>expire confirm 100 设置confirm这个key100秒过期</p>
<p>ttl confirm 获取confirm 这个key的有效时长</p>
<p>select 0 选择到0数据库 redis默认的数据库是0~15一共16个数据库</p>
<p>move confirm 1 将当前数据库中的key移动到其他的数据库中，这里就是把confire这个key从当前数据库中移动到1中</p>
<p>persist confirm 移除confirm这个key的过期时间</p>
<p>randomkey 随机返回数据库里面的一个key</p>
<p>rename key2 key3 重命名key2 为key3</p>
<p>type key2 返回key的数据类型</p>
<h1 id="服务器相关命令"><a href="#服务器相关命令" class="headerlink" title="服务器相关命令"></a>服务器相关命令</h1><p>ping PONG返回响应是否连接成功</p>
<p>echo 在命令行打印一些内容</p>
<p>select 0~15 编号的数据库</p>
<p>quit  /exit 退出客户端</p>
<p>dbsize 返回当前数据库中所有key的数量</p>
<p>info 返回redis的相关信息</p>
<p>config get dir/* 实时传储收到的请求</p>
<p>flushdb 删除当前选择数据库中的所有key</p>
<p>flushall 删除所有数据库中的数据库</p>
<pre><code>redis-cli KEYS &quot;pattern&quot; | xargs redis-cli DEL
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Key、服务器相关的一些常用redis命令。&lt;br&gt;速查：&lt;a href=&quot;http://www.cnblogs.com/kissdodog/p/3599047.html&quot;&gt;http://www.cnblogs.com/kissdodog/p/3599047.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="handbook" scheme="http://www.yangkai0725.com/categories/handbook/"/>
    
    
      <category term="java" scheme="http://www.yangkai0725.com/tags/java/"/>
    
      <category term="redis" scheme="http://www.yangkai0725.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis常用方法模板</title>
    <link href="http://www.yangkai0725.com/20160818/20160818mybatis%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%A8%A1%E6%9D%BF.html"/>
    <id>http://www.yangkai0725.com/20160818/20160818mybatis常用方法模板.html</id>
    <published>2016-08-18T13:00:41.000Z</published>
    <updated>2016-08-22T01:35:38.565Z</updated>
    
    <content type="html"><![CDATA[<p><em>常用mybatis模板批量删除、list查询、注解查询@Select。</em></p>
<a id="more"></a>
<h1 id="UUID主键"><a href="#UUID主键" class="headerlink" title="UUID主键"></a>UUID主键</h1><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;selectKey keyProperty=<span class="string">"id"</span> resultType=<span class="string">"String"</span> <span class="keyword">order</span>=<span class="string">"BEFORE"</span>&gt;</div><div class="line">   <span class="keyword">select</span> sys_guid() <span class="keyword">from</span> dual</div><div class="line">&lt;/selectKey&gt;</div></pre></td></tr></table></figure>
<h1 id="根据主键集合删除"><a href="#根据主键集合删除" class="headerlink" title="根据主键集合删除"></a>根据主键集合删除</h1><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public int delete(Object[] ids) throws Exception;</div><div class="line">&lt;delete id="delete"&gt;</div><div class="line">	delete from t_table where id in</div><div class="line">	&lt;foreach collection="array" index="index" item="ids" open="(" separator="," close=")"&gt;</div><div class="line">		#&#123;ids&#125;</div><div class="line">	&lt;/foreach&gt;</div><div class="line">&lt;/delete&gt;</div></pre></td></tr></table></figure>
<h1 id="根据属性值查找"><a href="#根据属性值查找" class="headerlink" title="根据属性值查找"></a>根据属性值查找</h1><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public List&lt;T&gt; findByList(Map&lt;String, Object&gt; map);</div><div class="line">&lt;sql id="sample_where_clause"&gt;</div><div class="line">	where 1=1</div><div class="line">	&lt;trim suffixOverrides=","&gt;</div><div class="line">		&lt;if test="id !=null and id !=''"&gt;</div><div class="line">			and id = #&#123;id&#125;</div><div class="line">		&lt;/if&gt;</div><div class="line">		&lt;if test="username !=null and username !=''"&gt;</div><div class="line">			and username = #&#123;username&#125;</div><div class="line">		&lt;/if&gt;</div><div class="line">	&lt;/trim&gt;</div><div class="line">&lt;/sql&gt;</div><div class="line">&lt;select id="findByList" resultMap="BaseResultMap" parameterType="Object"&gt;</div><div class="line">	select * from user</div><div class="line">	&lt;include refid="sample_where_clause" /&gt;</div><div class="line">&lt;/select&gt;</div></pre></td></tr></table></figure>
<h1 id="Select注解"><a href="#Select注解" class="headerlink" title="@Select注解"></a>@Select注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</div><div class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</div><div class="line"><span class="meta">@Select</span>(<span class="string">"select * from work_log where id = #&#123;id&#125;"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> WorkLog <span class="title">queryById</span><span class="params">(@Param(<span class="string">"id"</span>)</span>Integer id)</span>;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;常用mybatis模板批量删除、list查询、注解查询@Select。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="http://www.yangkai0725.com/categories/database/"/>
    
    
      <category term="java" scheme="http://www.yangkai0725.com/tags/java/"/>
    
      <category term="database" scheme="http://www.yangkai0725.com/tags/database/"/>
    
      <category term="mybatis" scheme="http://www.yangkai0725.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Freemarker内置对象</title>
    <link href="http://www.yangkai0725.com/20160818/20160818Freemarker%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1.html"/>
    <id>http://www.yangkai0725.com/20160818/20160818Freemarker内置对象.html</id>
    <published>2016-08-18T12:32:48.000Z</published>
    <updated>2016-08-22T01:35:38.777Z</updated>
    
    <content type="html"><![CDATA[<p><em>直接在ftl里使用内置对象:Request,Session,Application,RequestParameters,Parameters。</em></p>
<a id="more"></a>
<h1 id="Request-amp-Session-amp-Application"><a href="#Request-amp-Session-amp-Application" class="headerlink" title="Request &amp; Session &amp; Application"></a>Request &amp; Session &amp; Application</h1><blockquote>
<p>   用于获取Request对象中的attribute对象。<br>   例如：${Request[“method”]}是直接在页面输出属性值。相当于request.getAttribute(“method”);<br>   如果要进行判断    [#if Request[“method”] = “edit”]do something[/#if]</p>
</blockquote>
<p><em><strong>Session对应HttpSession,Application对应ServletContext,用法参考Request。</strong></em></p>
<h1 id="RequestParameters"><a href="#RequestParameters" class="headerlink" title="RequestParameters"></a>RequestParameters</h1><p>用于获取Request对象的parameter,例如${RequestParameters[“method”]}相当于request.getParameter(“method”);</p>
<h1 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h1><p>属性获取，依次从RequestParameters、Request、Session、Application对象中获取对应属性参数，一旦获取则不再往下寻找。例如：Parameters[“method”]</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;直接在ftl里使用内置对象:Request,Session,Application,RequestParameters,Parameters。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="handbook" scheme="http://www.yangkai0725.com/categories/handbook/"/>
    
    
      <category term="freemarker" scheme="http://www.yangkai0725.com/tags/freemarker/"/>
    
      <category term="java" scheme="http://www.yangkai0725.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 请求返回代码含义</title>
    <link href="http://www.yangkai0725.com/20160818/20160818httpStatusCode.html"/>
    <id>http://www.yangkai0725.com/20160818/20160818httpStatusCode.html</id>
    <published>2016-08-18T12:17:30.000Z</published>
    <updated>2016-08-22T01:35:38.770Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到RFC 2518、RFC 2817、RFC 2295、RFC 2774、RFC 4918等规范扩展。</strong></em></p>
<a id="more"></a>
<p>100  Continue  初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新）<br>101  Switching Protocols  服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1新）<br>200  OK  一切正常，对GET和POST请求的应答文档跟在后面。<br>201  Created  服务器已经创建了文档，Location头给出了它的URL。<br>202  Accepted  已经接受请求，但处理尚未完成。<br>203  Non-Authoritative Information  文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝（HTTP 1.1新）。<br>204  No Content  没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。<br>205  Reset Content  没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容（HTTP 1.1新）。<br>206  Partial Content  客户发送了一个带有Range头的GET请求，服务器完成了它（HTTP 1.1新）。<br>300  Multiple Choices  客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。<br>301  Moved Permanently  客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。<br>302  Found  类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。注意，在HTTP1.0中对应的状态信息是“Moved Temporatily”。<br>出现该状态代码时，浏览器能够自动访问新的URL，因此它是一个很有用的状态代码。<br>注意这个状态代码有时候可以和301替换使用。例如，如果浏览器错误地请求<code>http://host/~user</code>（缺少了后面的斜杠），有的服务器返回301，有的则返回302。<br>严格地说，我们只能假定只有当原来的请求是GET时浏览器才会自动重定向。请参见307。<br>303  See Other  类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取（HTTP 1.1新）。<br>304  Not Modified  客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。<br>305  Use Proxy  客户请求的文档应该通过Location头所指明的代理服务器提取（HTTP 1.1新）。<br>307  Temporary Redirect  和302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。（HTTP 1.1新）<br>400  Bad Request  请求出现语法错误。<br>401  Unauthorized  客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求。<br>403  Forbidden  资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。<br>404  Not Found  无法找到指定位置的资源。这也是一个常用的应答。<br>405  Method Not Allowed  请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。（HTTP 1.1新）<br>406  Not Acceptable  指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容（HTTP 1.1新）。<br>407  Proxy Authentication Required  类似于401，表示客户必须先经过代理服务器的授权。（HTTP 1.1新）<br>408  Request Timeout  在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。（HTTP 1.1新）<br>409  Conflict  通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。（HTTP 1.1新）<br>410  Gone  所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的原因文档不可用。（HTTP 1.1新）<br>411  Length Required  服务器不能处理请求，除非客户发送一个Content-Length头。（HTTP 1.1新）<br>412  Precondition Failed  请求头中指定的一些前提条件失败（HTTP 1.1新）。<br>413  Request Entity Too Large  目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头（HTTP 1.1新）。<br>414  Request URI Too Long  URI太长（HTTP 1.1新）。<br>416  Requested Range Not Satisfiable  服务器不能满足客户在请求中指定的Range头。（HTTP 1.1新）<br>500  Internal Server Error  服务器遇到了意料不到的情况，不能完成客户的请求。<br>501  Not Implemented  服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求。<br>502  Bad Gateway  服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。<br>503  Service Unavailable  服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个Retry-After头。<br>504  Gateway Timeout  由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。（HTTP 1.1新）<br>505  HTTP Version Not Supported  服务器不支持请求中所指明的HTTP版本。（HTTP 1.1新） </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;&lt;strong&gt;HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到RFC 2518、RFC 2817、RFC 2295、RFC 2774、RFC 4918等规范扩展。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="handbook" scheme="http://www.yangkai0725.com/categories/handbook/"/>
    
    
      <category term="java" scheme="http://www.yangkai0725.com/tags/java/"/>
    
      <category term="http" scheme="http://www.yangkai0725.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>揭秘Redis持久化</title>
    <link href="http://www.yangkai0725.com/20160816/20160816%E6%8F%AD%E7%A7%98Redis%E6%8C%81%E4%B9%85%E5%8C%96.html"/>
    <id>http://www.yangkai0725.com/20160816/20160816揭秘Redis持久化.html</id>
    <published>2016-08-16T04:54:34.000Z</published>
    <updated>2016-08-22T01:35:38.783Z</updated>
    
    <content type="html"><![CDATA[<p>什么是持久化，简单来讲就是将数据放到断电后数据不会丢失的设备中。也就是我们通常理解的硬盘上。<br><a id="more"></a></p>
<h1 id="写操作的流程"><a href="#写操作的流程" class="headerlink" title="写操作的流程"></a>写操作的流程</h1><hr>
<p>首先我们来看一下数据库在进行写操作时到底做了哪些事，主要有下面五个过程。</p>
<ol>
<li>客户端向服务端发送写操作（数据在客户端的内存中）</li>
<li>数据库服务端接收到写请求的数据（数据在服务端的内存中）</li>
<li>服务端调用write(2) 这个系统调用，将数据往磁盘上写（数据在系统内存的缓冲区中）</li>
<li>操作系统将缓冲区中的数据转移到磁盘控制器上（数据在磁盘缓存中）</li>
<li>磁盘控制器将数据写到磁盘的物理介质中（数据真正落到磁盘上）</li>
</ol>
<p>写操作大致有上面5个流程，下面我们结合上面的5个流程看一下各种级别的故障。</p>
<ul>
<li>当数据库系统故障时，这时候系统内核还是OK的，那么此时只要我们执行完了第3步，那么数据就是安全的，因为后续操作系统会来完成后面几步，保证数据最终会落到磁盘上。</li>
<li><p>当系统断电，这时候上面5项中提到的所有缓存都会失效，并且数据库和操作系统都会停止工作。所以只有当数据在完成第5步后，机器断电才能保证数据不丢失，在上述四步中的数据都会丢失。<br>通过上面5步的了解，可能我们会希望搞清下面一些问题：</p>
</li>
<li><p>数据库多长时间调用一次write(2)，将数据写到内核缓冲区</p>
</li>
<li>内核多长时间会将系统缓冲区中的数据写到磁盘控制器</li>
<li>磁盘控制器又在什么时候把缓存中的数据写到物理介质上<br>对于第一个问题，通常数据库层面会进行全面控制。而对第二个问题，操作系统有其默认的策略，但是我们也可以通过POSIX API提供的fsync系列命令强制操作系统将数据从内核区写到磁盘控制器上。对于第三个问题，好像数据库已经无法触及，但实际上，大多数情况下磁盘缓存是被设置关闭的。或者是只开启为读缓存，也就是写操作不会进行缓存，直接写到磁盘。建议的做法是仅仅当你的磁盘设备有备用电池时才开启写缓存。</li>
</ul>
<p>所谓数据损坏，就是数据无法恢复，上面我们讲的都是如何保证数据是确实写到磁盘上去，但是写到磁盘上可能并不意味着数据不会损坏。比如我们可能一次写请求会进行两次不同的写操作，当意外发生时，可能会导致一次写操作安全完成，但是另一次还没有进行。如果数据库的数据文件结构组织不合理，可能就会导致数据完全不能恢复的状况出现。</p>
<p>这里通常也有三种策略来组织数据，以防止数据文件损坏到无法恢复的情况：</p>
<ol>
<li>第一种是最粗糙的处理，就是不通过数据的组织形式保证数据的可恢复性。而是通过配置数据同步备份的方式，在数据文件损坏后通过数据备份来进行恢复。实际上MongoDB在不开启journaling日志，通过配置Replica Sets时就是这种情况。</li>
<li>另一种是在上面基础上添加一个操作日志，每次操作时记一下操作的行为，这样我们可以通过操作日志来进行数据恢复。因为操作日志是顺序追加的方式写的，所以不会出现操作日志也无法恢复的情况。这也类似于MongoDB开启了journaling日志的情况。</li>
<li>更保险的做法是数据库不进行老数据的修改，只是以追加方式去完成写操作，这样数据本身就是一份日志，这样就永远不会出现数据无法恢复的情况了。实际上CouchDB就是此做法的优秀范例。</li>
</ol>
<h1 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h1><hr>
<p>下面我们说一下Redis的第一个持久化策略，RDB快照。Redis支持将当前数据的快照存成一个数据文件的持久化机制。而一个持续写入的数据库如何生成快照呢。Redis借助了fork命令的copy on write机制。在生成快照时，将当前进程fork出一个子进程，然后在子进程中循环所有的数据，将数据写成为RDB文件。</p>
<p>我们可以通过Redis的save指令来配置RDB快照生成的时机，比如你可以配置当10分钟以内有100次写入就生成快照，也可以配置当1小时内有1000次写入就生成快照，也可以多个规则一起实施。这些规则的定义就在Redis的配置文件中，你也可以通过Redis的CONFIG SET命令在Redis运行时设置规则，不需要重启Redis。</p>
<p>Redis的RDB文件不会坏掉，因为其写操作是在一个新进程中进行的，当生成一个新的RDB文件时，Redis生成的子进程会先将数据写到一个临时文件中，然后通过原子性rename系统调用将临时文件重命名为RDB文件，这样在任何时候出现故障，Redis的RDB文件都总是可用的。</p>
<p>同时，Redis的RDB文件也是Redis主从同步内部实现中的一环。</p>
<p>但是，我们可以很明显的看到，RDB有他的不足，就是一旦数据库出现问题，那么我们的RDB文件中保存的数据并不是全新的，从上次RDB文件生成到Redis停机这段时间的数据全部丢掉了。在某些业务下，这是可以忍受的，我们也推荐这些业务使用RDB的方式进行持久化，因为开启RDB的代价并不高。但是对于另外一些对数据安全性要求极高的应用，无法容忍数据丢失的应用，RDB就无能为力了，所以Redis引入了另一个重要的持久化机制：AOF 日志。</p>
<h1 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h1><p>aof日志的全称是append only file，从名字上我们就能看出来，它是一个追加写入的日志文件。与一般数据库的binlog不同的是，AOF文件是可识别的纯文本，它的内容就是一个个的Redis标准命令。<br>比如我们进行如下实验，使用Redis2.6版本，在启动命令参数中设置开启aof功能：</p>
<pre><code>./redis-server --appendonly yes
</code></pre><p>然后我们执行如下的命令：</p>
<pre><code>redis 127.0.0.1:6379&gt; set key1 Hello
OK
redis 127.0.0.1:6379&gt; append key1 &quot; World!&quot;
(integer) 12
redis 127.0.0.1:6379&gt; del key1
(integer) 1
redis 127.0.0.1:6379&gt; del non_existing_key
(integer) 0
</code></pre><p>这时我们查看AOF日志文件，就会得到如下内容：</p>
<pre><code>$ cat appendonly.aof
*2
$6
SELECT
$1
0
*3
$3
set
$4
key1
$5
Hello
*3
$6
append
$4
key1
$7
World!
*2
$3
del
$4
key1
</code></pre><p>可以看到，写操作都生成了一条相应的命令作为日志。其中值得注意的是最后一个del命令，它并没有被记录在AOF日志中，这是因为Redis判断出这个命令不会对当前数据集做出修改。所以不需要记录这个无用的写命令。另外AOF日志也不是完全按客户端的请求来生成日志的，比如命令INCRBYFLOAT在记AOF日志时就被记成一条SET记录，因为浮点数操作可能在不同的系统上会不同，所以为了避免同一份日志在不同的系统上生成不同的数据集，所以这里只将操作后的结果通过SET来记录。</p>
<h1 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h1><hr>
<p>你可以会想，每一条写命令都生成一条日志，那么AOF文件是不是会很大？答案是肯定的，AOF文件会越来越大，所以Redis又提供了一个功能，叫做AOF rewrite。其功能就是重新生成一份AOF文件，新的AOF文件中一条记录的操作只会有一次，而不像一份老文件那样，可能记录了对同一个值的多次操作。其生成过程和RDB类似，也是fork一个进程，直接遍历数据，写入新的AOF临时文件。在写入新文件的过程中，所有的写操作日志还是会写到原来老的AOF文件中，同时还会记录在内存缓冲区中。当重完操作完成后，会将所有缓冲区中的日志一次性写入到临时文件中。然后调用原子性的rename命令用新的AOF文件取代老的AOF文件。</p>
<p>从上面的流程我们能够看到，RDB和AOF操作都是顺序IO操作，性能都很高。而同时在通过RDB文件或者AOF日志进行数据库恢复的时候，也是顺序的读取数据加载到内存中。所以也不会造成磁盘的随机读。</p>
<h1 id="AOF可靠性设置"><a href="#AOF可靠性设置" class="headerlink" title="AOF可靠性设置"></a>AOF可靠性设置</h1><hr>
<p>AOF是一个写文件操作，其目的是将操作日志写到磁盘上，所以它也同样会遇到我们上面说的写操作的5个流程。那么写AOF的操作安全性又有多高呢。实际上这是可以设置的，在Redis中对AOF调用write(2)写入后，何时再调用fsync将其写到磁盘上，通过appendfsync 选项来控制，下面appendfsync的三个设置项，安全强度逐渐变强。</p>
<h1 id="appendfsync-no"><a href="#appendfsync-no" class="headerlink" title="appendfsync no"></a>appendfsync no</h1><hr>
<p>当设置appendfsync为no的时候，Redis不会主动调用fsync去将AOF日志内容同步到磁盘，所以这一切就完全依赖于操作系统的调试了。对大多数Linux操作系统，是每30秒进行一次fsync，将缓冲区中的数据写到磁盘上。</p>
<h1 id="appendfsync-everysec"><a href="#appendfsync-everysec" class="headerlink" title="appendfsync everysec"></a>appendfsync everysec</h1><hr>
<p>当设置appendfsync为everysec的时候，Redis会默认每隔一秒进行一次fsync调用，将缓冲区中的数据写到磁盘。但是当这一次的fsync调用时长超过1秒时。Redis会采取延迟fsync的策略，再等一秒钟。也就是在两秒后再进行fsync，这一次的fsync就不管会执行多长时间都会进行。这时候由于在fsync时文件描述符会被阻塞，所以当前的写操作就会阻塞。 所以，结论就是，在绝大多数情况下，Redis会每隔一秒进行一次fsync。在最坏的情况下，两秒钟会进行一次fsync操作。</p>
<p>这一操作在大多数数据库系统中被称为group commit，就是组合多次写操作的数据，一次性将日志写到磁盘。</p>
<h1 id="appednfsync-always"><a href="#appednfsync-always" class="headerlink" title="appednfsync always"></a>appednfsync always</h1><hr>
<p>当设置appendfsync为always时，每一次写操作都会调用一次fsync，这时数据是最安全的，当然，由于每次都会执行fsync，所以其性能也会受到影响。</p>
<h1 id="对于pipelining有什么不同"><a href="#对于pipelining有什么不同" class="headerlink" title="对于pipelining有什么不同"></a>对于pipelining有什么不同</h1><hr>
<p>对于pipelining的操作，其具体过程是客户端一次性发送N个命令，然后等待这N个命令的返回结果被一起返回。通过采用pipilining就意味着放弃了对每一个命令的返回值确认。由于在这种情况下，N个命令是在同一个执行过程中执行的。所以当设置appendfsync为everysec时，可能会有一些偏差，因为这N个命令可能执行时间超过1秒甚至2秒。但是可以保证的是，最长时间不会超过这N个命令的执行时间和。</p>
<h1 id="与postgreSQL和MySQL的比较"><a href="#与postgreSQL和MySQL的比较" class="headerlink" title="与postgreSQL和MySQL的比较"></a>与postgreSQL和MySQL的比较</h1><hr>
<p>这一块就不多说了，由于上面操作系统层面的数据安全已经讲了很多，所以其实不同的数据库在实现上都大同小异。 总之最后的结论就是，在Redis开启AOF的情况下，其单机数据安全性并不比这些成熟的SQL数据库弱。</p>
<p>这些持久化的数据有什么用，当然是用于重启后的数据恢复。 Redis是一个内存数据库，无论是RDB还是AOF，都只是其保证数据恢复的措施。 所以Redis在利用RDB和AOF进行恢复的时候，都会读取RDB或AOF文件，重新加载到内存中。 相对于MySQL等数据库的启动时间来说，会长很多，因为MySQL本来是不需要将数据加载到内存中的。</p>
<p>但是相对来说，MySQL启动后提供服务时，其被访问的热数据也会慢慢加载到内存中，通常我们称之为预热，而在预热完成前，其性能都不会太高。而Redis的好处是一次性将数据加载到内存中，一次性预热。这样只要Redis启动完成，那么其提供服务的速度都是非常快的。</p>
<p>而在利用RDB和利用AOF启动上，其启动时间有一些差别。RDB的启动时间会更短，原因有两个，一是RDB文件中每一条数据只有一条记录，不会像AOF日志那样可能有一条数据的多次操作记录。所以每条数据只需要写一次就行了。另一个原因是RDB文件的存储格式和Redis数据在内存中的编码格式是一致的，不需要再进行数据编码工作。在CPU消耗上要远小于AOF日志的加载。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是持久化，简单来讲就是将数据放到断电后数据不会丢失的设备中。也就是我们通常理解的硬盘上。&lt;br&gt;
    
    </summary>
    
      <category term="handbook" scheme="http://www.yangkai0725.com/categories/handbook/"/>
    
    
      <category term="redis" scheme="http://www.yangkai0725.com/tags/redis/"/>
    
      <category term="database" scheme="http://www.yangkai0725.com/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建</title>
    <link href="http://www.yangkai0725.com/20160810/20160810%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E6%A8%A1%E6%9D%BF.html"/>
    <id>http://www.yangkai0725.com/20160810/20160810搭建Hexo博客模板.html</id>
    <published>2016-08-10T09:37:58.000Z</published>
    <updated>2016-08-22T01:35:38.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建参考地址"><a href="#搭建参考地址" class="headerlink" title="搭建参考地址"></a>搭建参考地址</h1><p><a href="http://jianbing.github.io/2016/03/03/set-up-blog/" target="_blank" rel="external">http://jianbing.github.io/2016/03/03/set-up-blog/</a><br><a id="more"></a></p>
<h1 id="Hexo-Landscape主题的字体和JS库优化"><a href="#Hexo-Landscape主题的字体和JS库优化" class="headerlink" title="Hexo Landscape主题的字体和JS库优化"></a>Hexo Landscape主题的字体和JS库优化</h1><p><a href="http://www.jianshu.com/p/ffcdc4fec6ec" target="_blank" rel="external">http://www.jianshu.com/p/ffcdc4fec6ec</a></p>
<h1 id="修改blog-config-yml"><a href="#修改blog-config-yml" class="headerlink" title="修改blog/_config.yml"></a>修改blog/_config.yml</h1><pre><code>deploy:
    type: git
    repository: git@github.com:eagleless/eagleless.github.io.git          
    branch: master
</code></pre><h1 id="生成SSH密钥过程"><a href="#生成SSH密钥过程" class="headerlink" title="生成SSH密钥过程"></a>生成SSH密钥过程</h1><ol>
<li>查看是否已经有了ssh密钥：cd ~/.ssh<br>如果没有密钥则不会有此文件夹，有则备份删除</li>
<li>生存密钥：<br>$ ssh-keygen -t rsa -C “fox520527088@163.com”<br>按3个回车，密码为空。</li>
</ol>
<p>Your identification has been saved in /home/tekkub/.ssh/id_rsa.<br>Your public key has been saved in /home/tekkub/.ssh/id_rsa.pub.<br>The key fingerprint is:<br>………………</p>
<p>最后得到了两个文件：id_rsa和id_rsa.pub</p>
<ol>
<li>添加密钥到ssh：ssh-add 文件名<br>需要之前输入密码。</li>
<li>在github上添加ssh密钥，这要添加的是“id_rsa.pub”里面的公钥。<br>打开<a href="https://github.com/" target="_blank" rel="external">https://github.com/</a> ，登录添加SSHKey。</li>
</ol>
<h1 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h1><pre><code>hexo n &quot;HelloWorld&quot;
hexo g
hexo d
hexo g -d
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;搭建参考地址&quot;&gt;&lt;a href=&quot;#搭建参考地址&quot; class=&quot;headerlink&quot; title=&quot;搭建参考地址&quot;&gt;&lt;/a&gt;搭建参考地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://jianbing.github.io/2016/03/03/set-up-blog/&quot;&gt;http://jianbing.github.io/2016/03/03/set-up-blog/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="note" scheme="http://www.yangkai0725.com/categories/note/"/>
    
    
      <category term="hexo" scheme="http://www.yangkai0725.com/tags/hexo/"/>
    
      <category term="git" scheme="http://www.yangkai0725.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown语法</title>
    <link href="http://www.yangkai0725.com/20160810/20160810markdown%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B.html"/>
    <id>http://www.yangkai0725.com/20160810/20160810markdown语法示例.html</id>
    <published>2016-08-10T08:16:01.000Z</published>
    <updated>2016-08-22T01:35:38.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown语法说明中文版"><a href="#Markdown语法说明中文版" class="headerlink" title="Markdown语法说明中文版"></a>Markdown语法说明中文版</h1><p><a href="http://www.appinn.com/markdown/" target="_blank" rel="external">http://www.appinn.com/markdown/</a></p>
<a id="more"></a>
<h1 id="Java代码格式"><a href="#Java代码格式" class="headerlink" title="Java代码格式"></a>Java代码格式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"HelloWorld"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Javascript代码格式"><a href="#Javascript代码格式" class="headerlink" title="Javascript代码格式"></a>Javascript代码格式</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsFunction</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="string">"javascript function"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Markdown表示h1-h6使用语法"><a href="#Markdown表示h1-h6使用语法" class="headerlink" title="Markdown表示h1-h6使用语法"></a>Markdown表示h1-h6使用语法</h1><p>类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶</p>
<pre><code># 这是 H1
## 这是 H2
###### 这是 H6
</code></pre><h1 id="链接语法"><a href="#链接语法" class="headerlink" title="链接语法"></a>链接语法</h1><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。</p>
<p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p>
<p>要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可。</p>
<h1 id="百度一下-你就知道"><a href="#百度一下-你就知道" class="headerlink" title="百度一下,你就知道"></a><a href="www.baidu.com">百度一下,你就知道</a></h1><pre><code>[百度一下,你就知道](www.baidu.com&quot;百度标题&quot;)
</code></pre><h1 id="Markdow图片"><a href="#Markdow图片" class="headerlink" title="Markdow图片"></a><a href="http://image.baidu.com/search/detail?ct=503316480&amp;z=0&amp;ipn=d&amp;word=%E5%9B%BE%E7%89%87&amp;hs=0&amp;pn=7&amp;spn=0&amp;di=147138333760&amp;pi=&amp;rn=1&amp;tn=baiduimagedetail&amp;ie=utf-8&amp;oe=utf-8&amp;cl=2&amp;lm=-1&amp;cs=1257261666%2C1562029974&amp;os=2547077022%2C2864557078&amp;simid=4212753602%2C624021646&amp;adpicid=0&amp;ln=30&amp;fr=ala&amp;fm=&amp;sme=&amp;cg=&amp;bdtype=0&amp;oriquery=&amp;objurl=http%3A%2F%2Fpic3.nipic.com%2F20090709%2F2893198_075124038_2.jpg&amp;fromurl=ippr_z2C%24qAzdH3FAzdH3Fooo_z%26e3Bgtrtv_z%26e3Bv54AzdH3Ffi5oAzdH3FnAzdH3F0nAzdH3F8klvkdw8vvvbw8bu_z%26e3Bip4s&amp;gsm=0" target="_blank" rel="external">Markdow图片</a></h1><pre><code>[Markdow图片](http://image.baidu.com/search/detail?ct=503316480&amp;z=0&amp;ipn=d&amp;word=%E5%9B%BE%E7%89%87&amp;hs=0&amp;pn=7&amp;spn=0&amp;di=147138333760&amp;pi=&amp;rn=1&amp;tn=baiduimagedetail&amp;ie=utf-8&amp;oe=utf-8&amp;cl=2&amp;lm=-1&amp;cs=1257261666%2C1562029974&amp;os=2547077022%2C2864557078&amp;simid=4212753602%2C624021646&amp;adpicid=0&amp;ln=30&amp;fr=ala&amp;fm=&amp;sme=&amp;cg=&amp;bdtype=0&amp;oriquery=&amp;objurl=http%3A%2F%2Fpic3.nipic.com%2F20090709%2F2893198_075124038_2.jpg&amp;fromurl=ippr_z2C%24qAzdH3FAzdH3Fooo_z%26e3Bgtrtv_z%26e3Bv54AzdH3Ffi5oAzdH3FnAzdH3F0nAzdH3F8klvkdw8vvvbw8bu_z%26e3Bip4s&amp;gsm=0)
</code></pre><h1 id="Markdown-Blod加粗显示"><a href="#Markdown-Blod加粗显示" class="headerlink" title="Markdown Blod加粗显示"></a><strong>Markdown Blod加粗显示</strong></h1><pre><code>**Markdown Blod加粗显示**
</code></pre><h1 id="Markdown-Italic斜体"><a href="#Markdown-Italic斜体" class="headerlink" title="Markdown Italic斜体"></a><em>Markdown Italic斜体</em></h1><pre><code>_Markdown Italic斜体_
</code></pre><h1 id="有序列表和无序列表"><a href="#有序列表和无序列表" class="headerlink" title="有序列表和无序列表"></a>有序列表和无序列表</h1><p>Markdown 支持有序列表和无序列表。无序列表使用星号、加号或是减号作为列表标记;有序列表则使用数字接着一个英文句点。</p>
<pre><code>*    Red
*   Green
*   Blue

1.  Bird
2.  McHale
3.  Parish
</code></pre><h1 id="Blockquote段落"><a href="#Blockquote段落" class="headerlink" title="Blockquote段落"></a>Blockquote段落</h1><p>Markdown Blockquote段落结构Web界面可以使用Flask框架来搭建，GUI界面可以使用TK，PyQT，wxPython等GUI库来编写，从学习成本来说，命令行界面是最容易上手，这一篇我们来聊一聊命令行界面的实现。</p>
<blockquote>
<p>This is the first level of quoting.</p>
<blockquote>
<p>This is nested blockquote.</p>
</blockquote>
<p>Back to the first level.</p>
</blockquote>
<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。</p>
<pre><code>* * *

***

*****

- - -

---------------------------------------
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Markdown语法说明中文版&quot;&gt;&lt;a href=&quot;#Markdown语法说明中文版&quot; class=&quot;headerlink&quot; title=&quot;Markdown语法说明中文版&quot;&gt;&lt;/a&gt;Markdown语法说明中文版&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.appinn.com/markdown/&quot;&gt;http://www.appinn.com/markdown/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="handbook" scheme="http://www.yangkai0725.com/categories/handbook/"/>
    
    
      <category term="markdown" scheme="http://www.yangkai0725.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>GitHub常用命令</title>
    <link href="http://www.yangkai0725.com/20160810/20160810GitHub%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"/>
    <id>http://www.yangkai0725.com/20160810/20160810GitHub常用命令.html</id>
    <published>2016-08-10T06:11:15.000Z</published>
    <updated>2016-08-22T01:35:38.806Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>   git clone<br>   git diff<br>   git log<br>   创建类命令<br><a id="more"></a></p>
</blockquote>
<h1 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h1><p>git clone 拷贝并跟踪远程的master分支。<br>跟踪的好处是以后可以直接通过pull和push命令来提交或者获取远程最新的代码，而不需要指定远程分支名字。</p>
<h1 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h1><blockquote>
<p>   对比工作区和stage文件的差异</p>
</blockquote>
<h1 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h1><blockquote>
<p>   显示到HEAD所指向的commit为止的所有commit记录 。使用reset HEAD~n 命令使HEAD指针向前移动，会导致HEAD之后的commit记录不会被显示。</p>
</blockquote>
<h1 id="创建类命令"><a href="#创建类命令" class="headerlink" title="创建类命令"></a>创建类命令</h1><ul>
<li>git brach branchName 创建名为branchName的branch </li>
<li>git checkout branchName 切换到branchName的branch </li>
<li>git checkout -b 创建并切换，也就是上面两个命令的合并</li>
<li>git brach branchName ef71 从commit ef71创建名为branchName的branch</li>
</ul>
<h1 id="提交类命令"><a href="#提交类命令" class="headerlink" title="提交类命令"></a>提交类命令</h1><ul>
<li>git add 跟踪新文件或者已有文件的改动，或者用来解决冲突</li>
<li>git commit 把文件从stage提交到branch</li>
<li>git commit -a 把修改的文件先提交到stage,然后再从stash提交到branch</li>
</ul>
<h1 id="删除类命令"><a href="#删除类命令" class="headerlink" title="删除类命令"></a>删除类命令</h1><ul>
<li>git rm –cached readme.txt 只从stage中删除，保留物理文件</li>
<li>git rm readme.txt 不但从stage中删除，同时删除物理文件</li>
<li>git mv a.txt b.txt 把a.txt改名为b.txt<h1 id="Merge类命令"><a href="#Merge类命令" class="headerlink" title="Merge类命令"></a>Merge类命令</h1></li>
</ul>
<blockquote>
<p>   在冲突状态下，需要解决冲突的文件会从index打回到工作区。</p>
<p>   1.用工具或者手工解决冲突<br>   2.git add 命令来表明冲突已经解决。<br>   3.再次commit 已解决冲突的文件。</p>
<p>   $ git reset –hard ORIG_HEAD 用来撤销已经commit 的merge.<br>   $ git reset –hard HEAD 用来撤销还没commit 的merge,其实原理就是放弃index和工作区的改动。</p>
<p>   git reset –merge ORIG_HEAD，注意其中的–hard 换成了 –merge，这样就可以避免在回滚时清除working tree。</p>
</blockquote>
<h1 id="用户名配置"><a href="#用户名配置" class="headerlink" title="用户名配置"></a>用户名配置</h1><pre><code>git config --global user.name &lt;your_name&gt;
例： $ git config --global user.name &quot;eagleless&quot;
</code></pre><h1 id="邮箱配置"><a href="#邮箱配置" class="headerlink" title="邮箱配置"></a>邮箱配置</h1><pre><code>git config --global user.email &lt;your_email@…&gt;
例： $ git config --global user.email fox22222@163.com
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;   git clone&lt;br&gt;   git diff&lt;br&gt;   git log&lt;br&gt;   创建类命令&lt;br&gt;
    
    </summary>
    
      <category term="handbook" scheme="http://www.yangkai0725.com/categories/handbook/"/>
    
    
      <category term="git" scheme="http://www.yangkai0725.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hexo使用简介HelloWorld</title>
    <link href="http://www.yangkai0725.com/20160809/20160809Hexo%E5%8D%9A%E5%AE%A2%E7%A4%BA%E4%BE%8B.html"/>
    <id>http://www.yangkai0725.com/20160809/20160809Hexo博客示例.html</id>
    <published>2016-08-09T09:37:58.000Z</published>
    <updated>2016-08-22T01:35:38.812Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bash</div><div class="line">$ hexo <span class="keyword">new</span> <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code>bash
$ hexo server
</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code>bash
$ hexo generate
</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code>bash
$ hexo deploy
</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="note" scheme="http://www.yangkai0725.com/categories/note/"/>
    
    
      <category term="hexo" scheme="http://www.yangkai0725.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>参考博客</title>
    <link href="http://www.yangkai0725.com/20160730/20160730%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2.html"/>
    <id>http://www.yangkai0725.com/20160730/20160730参考博客.html</id>
    <published>2016-07-30T14:17:26.000Z</published>
    <updated>2016-08-23T01:29:15.730Z</updated>
    
    <content type="html"><![CDATA[<p>网络博客学习缓存</p>
<a id="more"></a>
<h1 id="聊聊高并发系统之HTTP缓存"><a href="#聊聊高并发系统之HTTP缓存" class="headerlink" title="聊聊高并发系统之HTTP缓存"></a>聊聊高并发系统之HTTP缓存</h1><p><a href="http://geek.csdn.net/news/detail/96586" target="_blank" rel="external">http://geek.csdn.net/news/detail/96586</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络博客学习缓存&lt;/p&gt;
    
    </summary>
    
      <category term="note" scheme="http://www.yangkai0725.com/categories/note/"/>
    
    
      <category term="record" scheme="http://www.yangkai0725.com/tags/record/"/>
    
  </entry>
  
</feed>
